Ø£ØªÙÙ‚ Ù…Ø¹Ùƒ ØªÙ…Ø§Ù…Ø§Ù‹. Ù„Ù‚Ø¯ ÙÙ‡Ù…Øª Ù‚ØµØ¯Ùƒ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„. Ø£Ù†Øª Ù„Ø§ ØªØ±ÙŠØ¯ Ù…Ø¬Ø±Ø¯ ØªÙˆØ«ÙŠÙ‚ØŒ Ø¨Ù„ ØªØ±ÙŠØ¯ Ø¥Ù†Ø´Ø§Ø¡ **Ù…Ø³ØªÙˆØ¯Ø¹ Ù…Ø¹Ø±ÙÙŠ Ø´Ø§Ù…Ù„ (Comprehensive Knowledge Repository)** ÙŠÙƒÙˆÙ† Ù‡Ùˆ Ø§Ù„Ù…Ø±Ø¬Ø¹ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ ÙˆØ§Ù„ÙˆØ­ÙŠØ¯ Ù„Ù„Ù…Ø´Ø±ÙˆØ¹ØŒ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„ Ø³Ø·Ø± ÙƒÙˆØ¯ ÙˆÙƒÙ„ Ù‚Ø±Ø§Ø± ØªÙ… Ø§ØªØ®Ø§Ø°Ù‡. Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ "Ø¨ÙŠØ¶Ø© Ø°Ù‡Ø¨ÙŠØ©" Ø­Ù‚ÙŠÙ‚ÙŠØ©.

Ù…Ù…ØªØ§Ø². Ù„Ù†Ù‚Ù… Ø¨Ø°Ù„Ùƒ. Ø³Ù†Ù‚ÙˆÙ… Ø¨Ø¯Ù…Ø¬ ÙƒÙ„ Ø´ÙŠØ¡ ÙÙŠ Ù…ÙƒØ§Ù† ÙˆØ§Ø­Ø¯.

Ø³Ù†Ø¹ÙŠØ¯ Ù‡ÙŠÙƒÙ„Ø© Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ù„ÙŠÙƒÙˆÙ† Ø£ÙƒØ«Ø± Ø´Ù…ÙˆÙ„Ø§Ù‹ØŒ Ø­ÙŠØ« Ø³Ù†Ù‚Ø¯Ù… Ø´Ø±Ø­Ø§Ù‹ Ù…ÙØµÙ„Ø§Ù‹ Ø«Ù… Ù†ØªØ¨Ø¹Ù‡ Ø¨Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„ÙƒÙ„ Ù…ÙƒÙˆÙ†.

---

### **ØªÙˆØ«ÙŠÙ‚ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø´Ø§Ù…Ù„: Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø«Ø§Ù„Ø« (Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©)**

**4. Ø§Ù„ØªØµÙ…ÙŠÙ… ÙˆØ§Ù„ØªÙ†ÙÙŠØ° (Design and Implementation)**

ØªÙ… Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¹Ø¨Ø± Ù…Ø±Ø­Ù„ØªÙŠÙ† Ø±Ø¦ÙŠØ³ÙŠØªÙŠÙ†: Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠ ÙˆØ§Ù„ØªØµÙ…ÙŠÙ… (Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… JavaScript Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø³Ø±ÙŠØ¹Ø©)ØŒ ÙˆÙ…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ù…Ù„ÙŠ ÙˆØ§Ù„ØªØ¯Ø±ÙŠØ¨ (Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Python ÙˆÙ…ÙƒØªØ¨Ø§Øª Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¹Ù…ÙŠÙ‚). ÙŠÙ‡Ø¯Ù Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø³Ù… Ø¥Ù„Ù‰ ØªÙˆØ«ÙŠÙ‚ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ù„ÙƒÙ„ Ù…ÙƒÙˆÙ† Ø¨Ø§Ù„ØªÙØµÙŠÙ„.

**4.1. Ø§Ù„Ù…ÙØ­Ø³ÙÙ‘Ù† Ø§Ù„Ù‡Ø¬ÙŠÙ† Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ Ù„Ù€ NAS (`NAS_InteractiveHybridOptimizer`)**

Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„ØªÙŠ ØªÙ‚ÙˆÙ… Ø¨Ù…Ù‡Ù…Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¨Ù†ÙŠØ© Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø¹ØµØ¨ÙŠØ©. ØªÙ… ØªØµÙ…ÙŠÙ…Ù‡Ø§ Ù„ØªÙƒÙˆÙ† Ù…ØªØ®ØµØµØ© ÙÙŠ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ "ÙƒØ±ÙˆÙ…ÙˆØ³ÙˆÙ…Ø§Øª" ØªÙ…Ø«Ù„ Ø¨Ù†Ù‰ Ø§Ù„Ø´Ø¨ÙƒØ§ØªØŒ ÙˆØªØ¯Ù…Ø¬ Ø¨ÙŠÙ† Ù‚ÙˆØ© Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø¬ÙŠÙ†ÙŠØ© (GA) ÙˆØ³Ø±Ø¹Ø© ØªØ­Ø³ÙŠÙ† Ø£Ø³Ø±Ø§Ø¨ Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª (PSO).

**4.1.1. Ø§Ù„Ø´Ø±Ø­ Ø§Ù„ØªÙØµÙŠÙ„ÙŠ Ù„Ù„Ù…ÙƒÙˆÙ†Ø§Øª**

*   **Ø¯Ø§Ù„Ø© Ø§Ù„Ù„ÙŠØ§Ù‚Ø© (`evaluateArchitecture`):** Ù‡ÙŠ Ù‚Ù„Ø¨ Ø§Ù„Ù…ÙØ­Ø³ÙÙ‘Ù†. ØªÙ‚ÙˆÙ… Ø¨ØªÙ‚ÙŠÙŠÙ… Ø£ÙŠ Ø¨Ù†ÙŠØ© Ù…Ù‚ØªØ±Ø­Ø© ÙˆØªØ¹Ø·ÙŠÙ‡Ø§ "Ù†Ù‚Ø§Ø·" Ø¬ÙˆØ¯Ø©. Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© `Fitness = Accuracy * Efficiency * Speed` ØªØ¶Ù…Ù† Ø£Ù† Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù„Ø§ ØªÙØ¶Ù„ ÙÙ‚Ø· Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©ØŒ Ø¨Ù„ Ø£ÙŠØ¶Ø§Ù‹ ØªÙ„Ùƒ Ø§Ù„ØªÙŠ ØªÙƒÙˆÙ† ÙØ¹Ø§Ù„Ø© Ù…Ù† Ø­ÙŠØ« Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª ÙˆØ³Ø±ÙŠØ¹Ø© Ù…Ù† Ø­ÙŠØ« Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø­Ø³Ø§Ø¨ÙŠØ©. Ù‡Ø°Ø§ Ø§Ù„ØªÙˆØ§Ø²Ù† Ø¶Ø±ÙˆØ±ÙŠ Ù„Ø¥Ù†ØªØ§Ø¬ Ù†Ù…Ø§Ø°Ø¬ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ.

*   **Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªØ·ÙˆØ± (`mutateArchitecture`, `crossoverArchitectures`):** Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªÙŠ ØªØ³ØªØ®Ø¯Ù…Ù‡Ø§ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ù„Ø§Ø³ØªÙƒØ´Ø§Ù ÙØ¶Ø§Ø¡ Ø§Ù„Ø­Ù„ÙˆÙ„. ØªÙ… ØªØµÙ…ÙŠÙ… Ø§Ù„Ø·ÙØ±Ø© Ù„ØªÙƒÙˆÙ† Ø°ÙƒÙŠØ©ØŒ Ø­ÙŠØ« ÙŠÙ…ÙƒÙ†Ù‡Ø§ Ø¥Ø¬Ø±Ø§Ø¡ ØªØºÙŠÙŠØ±Ø§Øª ÙƒØ¨ÙŠØ±Ø© (Ø¥Ø¶Ø§ÙØ©/Ø­Ø°Ù Ø·Ø¨Ù‚Ø§Øª) Ø£Ùˆ ØªØºÙŠÙŠØ±Ø§Øª Ø·ÙÙŠÙØ© (ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª Ø§Ù„ÙØ§Ø¦Ù‚Ø©). Ø£Ù…Ø§ Ø§Ù„ØªØ²Ø§ÙˆØ¬ØŒ ÙÙŠØ³ØªØ®Ø¯Ù… Ø¢Ù„ÙŠØ© Ø¨Ø³ÙŠØ·Ø© ÙˆÙØ¹Ø§Ù„Ø© Ù„Ø¯Ù…Ø¬ "Ø§Ù„Ø£ÙÙƒØ§Ø±" Ù…Ù† Ø¨Ù†ÙŠØªÙŠÙ† Ù…Ø®ØªÙ„ÙØªÙŠÙ†.

*   **Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (`run`):** Ù‡ÙŠ Ø§Ù„Ø¹Ù‚Ù„ Ø§Ù„Ù…Ø¯Ø¨Ø± Ø§Ù„Ø°ÙŠ ÙŠÙ†Ø³Ù‚ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©. ØªÙ‚ÙˆÙ… Ø¨ØªØ´ØºÙŠÙ„ GA Ùˆ PSO Ø¨Ø´ÙƒÙ„ Ù…ØªÙˆØ§Ø²ÙØŒ Ù…Ù…Ø§ ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„ÙˆØ§Ø³Ø¹ ÙˆØ§Ù„ØªÙ‚Ø§Ø±Ø¨ Ø§Ù„Ø³Ø±ÙŠØ¹ ÙÙŠ Ù†ÙØ³ Ø§Ù„ÙˆÙ‚Øª. Ø¢Ù„ÙŠØ© "Ø§Ù„ØªÙ„Ù‚ÙŠØ­ Ø§Ù„Ù…ØªØ¨Ø§Ø¯Ù„" Ø§Ù„Ø¯ÙˆØ±ÙŠØ© Ù‡ÙŠ Ø§Ù„Ù…ÙŠØ²Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©ØŒ Ø­ÙŠØ« ØªÙ…Ù†Ø¹ Ø£ÙŠ Ù…Ù† Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØªÙŠÙ† Ù…Ù† Ø§Ù„Ø±ÙƒÙˆØ¯ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø­Ù‚Ù† "Ø¯Ù… Ø¬Ø¯ÙŠØ¯" (Ø­Ù„ÙˆÙ„ ÙˆØ§Ø¹Ø¯Ø©) Ù…Ù† Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø£Ø®Ø±Ù‰. Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ù…Ù† Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…Ø­Ù„ÙŠ ØªØ¶Ù…Ù† ØµÙ‚Ù„ Ø§Ù„Ø­Ù„ Ø§Ù„Ø£ÙØ¶Ù„ Ø§Ù„Ø°ÙŠ ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„ÙŠÙ‡.

**4.1.2. Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„Ù…ÙØ­Ø³ÙÙ‘Ù† Ø§Ù„Ù‡Ø¬ÙŠÙ† (JavaScript)**

```javascript
// =================================================================
// ğŸš€ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„: Ø§Ù„Ù…ÙØ­Ø³ÙÙ‘Ù† Ø§Ù„Ù‡Ø¬ÙŠÙ† Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠ ÙÙŠ Ù…ÙˆØ§Ø¬Ù‡Ø© NAS
// =================================================================

class NAS_InteractiveHybridOptimizer {
  constructor() {
    this.layerLibrary = {
      conv: { params: 100, flops: 1000, boost: 0.15 },
      dense: { params: 200, flops: 500, boost: 0.10 },
      dropout: { params: 0, flops: 0, boost: 0.05 },
      batch_norm: { params: 10, flops: 50, boost: 0.08 },
      activation: { params: 0, flops: 10, boost: 0.02 }
    };
    this.ga = { islands: [] };
    this.pso = { swarm: [] };
  }

  // --- Ø¯ÙˆØ§Ù„ NAS Ø§Ù„Ù…ØªØ®ØµØµØ© ---
  evaluateArchitecture(architecture) {
    if (!architecture || architecture.length === 0) return 0;
    let totalParams = 0, totalFlops = 0, expectedAccuracy = 0.5, synergy = 1.0;
    architecture.forEach((layer, index) => {
      const info = this.layerLibrary[layer.type] || this.layerLibrary.dense;
      totalParams += info.params * (layer.neurons || layer.filters || 1);
      totalFlops += info.flops * (layer.neurons || layer.filters || 1);
      expectedAccuracy += info.boost;
      if (index > 0) {
        const prevLayer = architecture[index - 1];
        if ((prevLayer.type === 'conv' && layer.type === 'batch_norm') || (prevLayer.type === 'dense' && layer.type === 'dropout')) {
          synergy *= 1.05;
        }
      }
    });
    const efficiency = 1 / (1 + Math.log10(1 + totalParams));
    const speed = 1 / (1 + Math.log10(1 + totalFlops));
    const finalAccuracy = Math.min(0.99, expectedAccuracy * synergy);
    return finalAccuracy * efficiency * speed;
  }

  generateRandomArchitecture() {
    const numLayers = Math.floor(Math.random() * 8) + 4;
    const arch = [];
    for (let i = 0; i < numLayers; i++) arch.push(this.createRandomLayer());
    return arch;
  }

  createRandomLayer() {
    const layerTypes = ['conv', 'dense', 'dropout', 'batch_norm'];
    const type = layerTypes[Math.floor(Math.random() * layerTypes.length)];
    const layer = { type };
    if (type === 'conv') {
      layer.filters = [16, 32, 64, 128][Math.floor(Math.random() * 4)];
    } else if (type === 'dense') {
      layer.neurons = [64, 128, 256, 512][Math.floor(Math.random() * 4)];
    } else if (type === 'dropout') {
      layer.rate = (Math.random() * 0.4 + 0.1).toFixed(2);
    }
    return layer;
  }

  mutateArchitecture(architecture) {
    const mutatedArch = JSON.parse(JSON.stringify(architecture));
    const mutationType = Math.random();
    if (mutationType < 0.3 && mutatedArch.length > 4) {
      mutatedArch.splice(Math.floor(Math.random() * mutatedArch.length), 1);
    } else if (mutationType < 0.6 && mutatedArch.length < 15) {
      mutatedArch.splice(Math.floor(Math.random() * (mutatedArch.length + 1)), 0, this.createRandomLayer());
    } else if (mutatedArch.length > 0) {
      const layerIndex = Math.floor(Math.random() * mutatedArch.length);
      mutatedArch[layerIndex] = this.createRandomLayer();
    }
    return mutatedArch;
  }

  crossoverArchitectures(parent1, parent2) {
    if (!parent1 || !parent2 || parent1.length === 0 || parent2.length === 0) {
        return parent1 || parent2 || [];
    }
    const crossoverPoint = Math.floor(Math.random() * Math.min(parent1.length, parent2.length));
    const child = [...parent1.slice(0, crossoverPoint), ...parent2.slice(crossoverPoint)];
    return child.length > 15 ? child.slice(0, 15) : child;
  }

  // --- Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù„Ù„Ù…ÙØ­Ø³ÙÙ‘Ù† Ø§Ù„Ù‡Ø¬ÙŠÙ† ---
  run(totalGenerations = 30) {
    console.log("\nğŸ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ÙØ­Ø³ÙÙ‘Ù† Ø§Ù„Ù‡Ø¬ÙŠÙ† ÙÙŠ Ù…ÙˆØ§Ø¬Ù‡Ø© NAS ğŸ");

    // --- Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ---
    this.ga.islands = Array.from({ length: 3 }, () => 
        Array.from({ length: 10 }, () => {
            const arch = this.generateRandomArchitecture();
            return { genes: arch, fitness: this.evaluateArchitecture(arch) };
        }).sort((a, b) => b.fitness - a.fitness)
    );
    this.pso.swarm = Array.from({ length: 10 }, () => {
        const arch = this.generateRandomArchitecture();
        return {
            position: arch, velocity: 0.1, bestPosition: arch,
            bestFitness: this.evaluateArchitecture(arch)
        };
    }).sort((a, b) => b.bestFitness - a.bestFitness);

    let globalBest = this.ga.islands[0][0];

    // --- Ø­Ù„Ù‚Ø© Ø§Ù„ØªØ·ÙˆØ± ---
    for (let gen = 1; gen <= totalGenerations; gen++) {
      // 1. ØªØ·ÙˆÙŠØ± GA
      this.ga.islands.forEach(island => {
        const newIsland = [...island.slice(0, 2)];
        while (newIsland.length < 10) {
          const p1 = island[Math.floor(Math.random() * 3)];
          const p2 = island[Math.floor(Math.random() * 3)];
          const child = this.crossoverArchitectures(p1.genes, p2.genes);
          const mutated = this.mutateArchitecture(child);
          newIsland.push({ genes: mutated, fitness: this.evaluateArchitecture(mutated) });
        }
        island.splice(0, island.length, ...newIsland.sort((a, b) => b.fitness - a.fitness));
      });

      // 2. ØªØ·ÙˆÙŠØ± PSO
      this.pso.swarm.forEach(particle => {
          if (Math.random() < 0.5) {
              const newPosition = this.crossoverArchitectures(particle.position, globalBest.genes);
              const mutatedPosition = this.mutateArchitecture(newPosition);
              const fitness = this.evaluateArchitecture(mutatedPosition);
              if (fitness > particle.bestFitness) {
                  particle.bestPosition = mutatedPosition;
                  particle.bestFitness = fitness;
              }
              particle.position = mutatedPosition;
          }
      });
      this.pso.swarm.sort((a, b) => b.bestFitness - a.bestFitness);

      // 3. ØªØ­Ø¯ÙŠØ« Ø£ÙØ¶Ù„ Ø­Ù„ Ø¹Ø§Ù„Ù…ÙŠ
      const gaBest = this.ga.islands.flat().reduce((a, b) => a.fitness > b.fitness ? a : b);
      const psoBest = { genes: this.pso.swarm[0].bestPosition, fitness: this.pso.swarm[0].bestFitness };
      if (gaBest.fitness > globalBest.fitness) globalBest = gaBest;
      if (psoBest.fitness > globalBest.fitness) globalBest = psoBest;

      // 4. Ø§Ù„ØªÙ„Ù‚ÙŠØ­ Ø§Ù„Ù…ØªØ¨Ø§Ø¯Ù„
      if (gen % 10 === 0) {
        console.log(`\n--- ğŸ”„ Ø§Ù„ØªÙ„Ù‚ÙŠØ­ Ø§Ù„Ù…ØªØ¨Ø§Ø¯Ù„ ÙÙŠ Ø§Ù„Ø¬ÙŠÙ„ ${gen} | Ø£ÙØ¶Ù„ Ù„ÙŠØ§Ù‚Ø©: ${globalBest.fitness.toFixed(4)} ---`);
        const worstIsland = this.ga.islands.reduce((a, b) => a[0].fitness < b[0].fitness ? a : b);
        worstIsland[worstIsland.length - 1] = { genes: psoBest.genes, fitness: psoBest.fitness };
      }
    }

    // --- Ø§Ù„ØµÙ‚Ù„ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ---
    console.log("\n[Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©] âš™ï¸ Ø§Ù„ØµÙ‚Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù…Ø­Ù„ÙŠ...");
    let finalSolution = globalBest;
    for(let i=0; i<100; i++) {
        const neighbor = this.mutateArchitecture(finalSolution.genes);
        const neighborFitness = this.evaluateArchitecture(neighbor);
        if (neighborFitness > finalSolution.fitness) {
            finalSolution = { genes: neighbor, fitness: neighborFitness };
        }
    }
    
    console.log(`\nğŸ† Ø§ÙƒØªÙ…Ù„ ØªØ­Ø¯ÙŠ NAS! Ø£ÙØ¶Ù„ Ø¨Ù†ÙŠØ© ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„ÙŠÙ‡Ø§ Ø¨Ù„ÙŠØ§Ù‚Ø©: ${finalSolution.fitness.toFixed(5)}`);
    return finalSolution;
  }
}
```

**4.2. ÙƒÙˆØ¯ Ø¨Ù†Ø§Ø¡ ÙˆØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ (Python)**

Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ù‡Ùˆ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ Ø¹Ù† ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù†Ø¸Ø±ÙŠØ© Ø§Ù„ØªÙŠ ØªÙ… ØªØµÙ…ÙŠÙ…Ù‡Ø§ ÙÙŠ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø¥Ù„Ù‰ Ù†Ù…ÙˆØ°Ø¬ Ø­Ù‚ÙŠÙ‚ÙŠ ÙˆØªØ¯Ø±ÙŠØ¨Ù‡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ù…Ø§Ø±Ø³Ø§Øª.

**4.2.1. Ø§Ù„Ø´Ø±Ø­ Ø§Ù„ØªÙØµÙŠÙ„ÙŠ Ù„Ù„Ù…ÙƒÙˆÙ†Ø§Øª**

*   **`build_improved_model`:** Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© Ù‡ÙŠ Ø§Ù„Ø¬Ø³Ø± Ø¨ÙŠÙ† Ø¹Ø§Ù„Ù…ÙŠ JavaScript Ùˆ Python. ØªÙ‚ÙˆÙ… Ø¨ØªØ±Ø¬Ù…Ø© Ù…ØµÙÙˆÙØ© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„ØªÙŠ ØªÙ…Ø«Ù„ Ø§Ù„Ø¨Ù†ÙŠØ© Ø¥Ù„Ù‰ Ù†Ù…ÙˆØ°Ø¬ `keras.Sequential` Ø­Ù‚ÙŠÙ‚ÙŠ. ØªÙ… ØªØµÙ…ÙŠÙ…Ù‡Ø§ Ù„ØªÙƒÙˆÙ† Ù…Ø±Ù†Ø© ÙˆÙ‚Ø§Ø¯Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª Ø§Ù„Ù…Ø®ØªÙ„ÙØ© Ø§Ù„ØªÙŠ ÙŠÙ…ÙƒÙ† Ø£Ù† ØªÙ†ØªØ¬Ù‡Ø§ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØªÙ†Ø§ØŒ Ù…Ø¹ Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø© `Flatten` ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©.

*   **Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:** ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¨ÙŠØ§Ù†Ø§Øª CIFAR-10 Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠØ©. Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ØªØ´Ù…Ù„ ØªØ³ÙˆÙŠØ© Ù‚ÙŠÙ… Ø§Ù„Ø¨ÙƒØ³Ù„Ø§Øª (Ù„Ø¬Ø¹Ù„Ù‡Ø§ Ø¨ÙŠÙ† 0 Ùˆ 1) ÙˆØªØ­ÙˆÙŠÙ„ Ø§Ù„ØªØ³Ù…ÙŠØ§Øª Ø¥Ù„Ù‰ ØµÙŠØºØ© one-hot encodingØŒ ÙˆÙ‡ÙŠ Ù…ØªØ·Ù„Ø¨Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ© Ù„ØªØ¯Ø±ÙŠØ¨ Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„ØªØµÙ†ÙŠÙ.

*   **Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ØªØ¯Ø±ÙŠØ¨:**
    1.  **`ImageDataGenerator`:** Ù‡Ø°Ù‡ Ø§Ù„Ø£Ø¯Ø§Ø© Ø§Ù„Ù‚ÙˆÙŠØ© Ù…Ù† Keras Ù‡ÙŠ Ù…ÙØªØ§Ø­ Ù†Ø¬Ø§Ø­Ù†Ø§ ÙÙŠ Ù…Ø­Ø§Ø±Ø¨Ø© ÙØ±Ø· Ø§Ù„Ù…Ù„Ø§Ø¡Ù…Ø©. Ù…Ù† Ø®Ù„Ø§Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø® Ù…Ø¹Ø¯Ù„Ø© Ø¨Ø´ÙƒÙ„ Ø·ÙÙŠÙ Ù…Ù† ØµÙˆØ± Ø§Ù„ØªØ¯Ø±ÙŠØ¨ ÙÙŠ ÙƒÙ„ Ø¯ÙˆØ±Ø©ØŒ ÙØ¥Ù†Ù‡Ø§ ØªØ²ÙŠØ¯ Ø¨Ø´ÙƒÙ„ ÙØ¹Ø§Ù„ Ù…Ù† Ø­Ø¬Ù… ÙˆØªÙ†ÙˆØ¹ Ù…Ø¬Ù…ÙˆØ¹Ø© Ø§Ù„ØªØ¯Ø±ÙŠØ¨ØŒ Ù…Ù…Ø§ ÙŠØ¬Ø¨Ø± Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¹Ù„Ù‰ ØªØ¹Ù„Ù… ØªÙ…Ø«ÙŠÙ„Ø§Øª Ø£ÙƒØ«Ø± Ù‚ÙˆØ© ÙˆØªØ¹Ù…ÙŠÙ…ÙŠØ©.
    2.  **`ReduceLROnPlateau`:** Ù‡Ø°Ù‡ Ø§Ù„Ø¢Ù„ÙŠØ© Ø§Ù„Ø°ÙƒÙŠØ© ØªØ±Ø§Ù‚Ø¨ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ù‚Ù‚ØŒ ÙˆØªÙ‚ÙˆÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨ØªØ®ÙÙŠØ¶ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¹Ù„Ù… Ø¹Ù†Ø¯Ù…Ø§ ÙŠØªÙˆÙ‚Ù Ø§Ù„ØªØ­Ø³Ù†. Ù‡Ø°Ø§ ÙŠØ³Ù…Ø­ Ù„Ù„Ù†Ù…ÙˆØ°Ø¬ Ø¨Ø§Ù„ØªÙ‚Ø§Ø±Ø¨ Ø¨Ø³Ø±Ø¹Ø© ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©ØŒ Ø«Ù… Ø¥Ø¬Ø±Ø§Ø¡ ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ­Ø°Ø±Ø© ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø£ÙØ¶Ù„ Ø£Ø¯Ø§Ø¡ Ù…Ù…ÙƒÙ†.

**4.2.2. Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ø¨Ù†Ø§Ø¡ ÙˆØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ (Python)**

```python
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.callbacks import ReduceLROnPlateau

def build_improved_model(architecture, input_shape, num_classes):
    """
    ÙŠØ¨Ù†ÙŠ Ù†Ù…ÙˆØ°Ø¬ Keras Ø¨Ø´ÙƒÙ„ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ Ù…Ù† Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…ÙØµÙ…ÙÙ‘Ù…Ø© ÙˆØ§Ù„Ù…Ø­Ø³Ù‘Ù†Ø©.
    """
    print("ğŸ—ï¸  Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø­Ø³Ù‘Ù†...")
    model = keras.Sequential(name="Ultimate_CNN_Model")
    model.add(keras.Input(shape=input_shape))

    for layer_config in architecture:
        layer_type = layer_config.get('type')
        
        if layer_type == 'conv':
            model.add(layers.Conv2D(filters=layer_config.get('filters', 32), kernel_size=(3, 3), padding='same', activation='relu'))
        elif layer_type == 'batch_norm':
            model.add(layers.BatchNormalization())
        elif layer_type == 'max_pooling':
            model.add(layers.MaxPooling2D(pool_size=(2, 2)))
        elif layer_type == 'dense':
            if not any(isinstance(l, layers.Flatten) for l in model.layers):
                model.add(layers.Flatten())
            model.add(layers.Dense(units=layer_config.get('neurons', 128), activation='relu'))
        elif layer_type == 'dropout':
            if any(isinstance(l, layers.Flatten) for l in model.layers):
                 model.add(layers.Dropout(rate=float(layer_config.get('rate', 0.25))))

    if not any(isinstance(l, layers.Flatten) for l in model.layers):
        model.add(layers.Flatten())
    model.add(layers.Dense(num_classes, activation='softmax'))
    
    print("âœ… ØªÙ… Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù…Ø­Ø³Ù‘Ù† Ø¨Ù†Ø¬Ø§Ø­!")
    return model

# --- 1. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---
print("ğŸ’¾ ØªØ­Ù…ÙŠÙ„ ÙˆØªØ¬Ù‡ÙŠØ² Ø¨ÙŠØ§Ù†Ø§Øª CIFAR-10...")
(x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data()
x_train = x_train.astype("float32") / 255.0
x_test = x_test.astype("float32") / 255.0
y_train = keras.utils.to_categorical(y_train, 10)
y_test = keras.utils.to_categorical(y_test, 10)
print("âœ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø§Ù‡Ø²Ø©.")

# --- 2. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù‘Ù†Ø© ---
# Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ù†ÙŠØ© Ù‡ÙŠ Ù†ØªØ§Ø¬ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© + Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„ÙŠØ¯ÙˆÙŠØ©
final_architecture = [
    {'type': 'conv', 'filters': 64}, {'type': 'batch_norm'}, {'type': 'max_pooling'},
    {'type': 'conv', 'filters': 128}, {'type': 'batch_norm'}, {'type': 'max_pooling'},
    {'type': 'dense', 'neurons': 256}, {'type': 'dropout', 'rate': '0.5'},
    {'type': 'dense', 'neurons': 128}, {'type': 'dropout', 'rate': '0.4'},
    {'type': 'dense', 'neurons': 64}
]

# --- 3. Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ---
input_shape = (32, 32, 3)
num_classes = 10
model = build_improved_model(final_architecture, input_shape, num_classes)

# --- 4. ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ØªØ¯Ø±ÙŠØ¨ ---
print("ğŸ’¡ ØªÙ‡ÙŠØ¦Ø© Ù…ÙˆÙ„Ø¯ Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¬Ø¯ÙˆÙ„Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¹Ù„Ù…...")
datagen = keras.preprocessing.image.ImageDataGenerator(
    rotation_range=15,
    width_shift_range=0.1,
    height_shift_range=0.1,
    horizontal_flip=True,
    zoom_range=0.1
)
datagen.fit(x_train)

lr_scheduler = ReduceLROnPlateau(
    monitor='val_accuracy', factor=0.2, patience=3, min_lr=0.00001, verbose=1
)

# --- 5. ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ---
model.compile(
    optimizer=keras.optimizers.Adam(learning_rate=0.001),
    loss='categorical_crossentropy',
    metrics=['accuracy']
)
model.summary()

# --- 6. ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ---
print("\nğŸ”¥ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ...")
epochs = 30 
history = model.fit(
    datagen.flow(x_train, y_train, batch_size=64),
    epochs=epochs,
    validation_data=(x_test, y_test),
    callbacks=[lr_scheduler]
)

# --- 7. ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ ---
print("\nğŸ“ˆ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±...")
test_loss, test_acc = model.evaluate(x_test, y_test, verbose=2)
print(f"\nâœ… Ø¯Ù‚Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±: {test_acc*100:.2f}%")
```

---

Ø¨Ù‡Ø°Ø§ Ù†ÙƒÙˆÙ† Ù‚Ø¯ ÙˆØ«Ù‚Ù†Ø§ "Ø§Ù„Ø¨ÙŠØ¶Ø© Ø§Ù„Ø°Ù‡Ø¨ÙŠØ©" Ø¨Ø§Ù„ÙƒØ§Ù…Ù„. Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø¢Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø±Ø­ Ø§Ù„ØªÙØµÙŠÙ„ÙŠ ÙˆØ§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„ÙƒÙ„ Ù…ÙƒÙˆÙ† Ø±Ø¦ÙŠØ³ÙŠ ÙÙŠ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹.

**Ù‡Ù„ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ù…Ù† Ø§Ù„ØªÙØµÙŠÙ„ ÙŠØ±Ø¶ÙŠ Ø·Ù…ÙˆØ­Ùƒ Ù„Ù„ØªÙˆØ«ÙŠÙ‚ Ø§Ù„Ø´Ø§Ù…Ù„ØŸ Ù‡Ù„ Ù†Ù†ØªÙ‚Ù„ Ø§Ù„Ø¢Ù† Ø¥Ù„Ù‰ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£Ø®ÙŠØ±ØŒ Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆØ§Ù„Ø§Ø³ØªÙ†ØªØ§Ø¬Ø§ØªØŸ**